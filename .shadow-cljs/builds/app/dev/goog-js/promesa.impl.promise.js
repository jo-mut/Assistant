["^ ","~:resource-id",["~:shadow.build.classpath/resource","promesa/impl/promise.js"],"~:js","goog.provide(\"promesa.impl.promise\");\ngoog.provide(\"promesa.impl.promise.PromiseImpl\");\ngoog.provide(\"promesa.impl.promise.CancellationError\");\ngoog.scope(function() {\n  function isCancellationError(v) {\n    return v instanceof CancellationError;\n  }\n  function fmtValue(o) {\n    if (isThenable(o)) {\n      return \"\\x3cPROMISE:\" + goog.getUid(o) + \"\\x3e\";\n    } else if (o instanceof Error) {\n      return \"\\x3cEXCEPTION:'\" + o.message + \"'\\x3e\";\n    } else if (o === null || o === undefined) {\n      return \"\" + o;\n    } else if (typeof o === \"function\") {\n      return \"\\x3cFN:\" + goog.getUid(o) + \"\\x3e\";\n    } else {\n      return \"\" + o.toString();\n    }\n  }\n  function isSome(o) {\n    return o !== null && o !== undefined;\n  }\n  function isFunction(o) {\n    return typeof o === \"function\";\n  }\n  function isThenable(o) {\n    if (goog.isObject(o)) {\n      var thenFn = o.then;\n      return isFunction(thenFn);\n    } else {\n      return false;\n    }\n  }\n  function constantly(v) {\n    return function() {\n      return v;\n    };\n  }\n  function identity(v) {\n    return v;\n  }\n  function isPromiseImpl(v) {\n    return v instanceof PromiseImpl;\n  }\n  function completeDeferredFn(deferred) {\n    return function(value, cause) {\n      if (cause) {\n        deferred.reject(cause);\n      } else {\n        deferred.resolve(value);\n      }\n    };\n  }\n  function process(p) {\n    if (p[STATE] === PENDING) {\n      return;\n    }\n    nextTick(processNextTick, p);\n    return p;\n  }\n  function processNextTick(p) {\n    if (p[QUEUE].length === 0) {\n      return;\n    }\n    var state = p[STATE];\n    var value = p[VALUE];\n    var task;\n    var rvalue;\n    var rcause;\n    for (; p[QUEUE].length;) {\n      task = p[QUEUE].shift();\n      try {\n        if (state === RESOLVED) {\n          rvalue = task.resolve(value);\n        } else if (state === REJECTED) {\n          rvalue = task.reject(value);\n        } else {\n          rcause = new TypeError(\"invalid state\");\n        }\n      } catch (e) {\n        rcause = e;\n      }\n      resolveTask(task, rvalue, rcause);\n    }\n  }\n  function resolveTask(task, value, cause) {\n    if (task.complete === undefined) {\n      return;\n    }\n    if (cause) {\n      task.complete(null, cause);\n    } else {\n      if (task.type === RESOLVE_TYPE_MAP) {\n        task.complete(value, null);\n      } else if (task.type === RESOLVE_TYPE_FLATTEN) {\n        if (isPromiseImpl(value)) {\n          value.handle(function(v, c) {\n            resolveTask(task, v, c);\n          });\n        } else if (isThenable(value)) {\n          value.then(function(v) {\n            resolveTask(task, v, null);\n          }, function(c) {\n            resolveTask(task, null, c);\n          });\n        } else {\n          task.complete(value, null);\n        }\n      } else if (task.type === RESOLVE_TYPE_BIND) {\n        if (isPromiseImpl(value)) {\n          value.handle(function(v, c) {\n            task.complete(v, c);\n          });\n        } else if (isThenable(value)) {\n          value.then(function(v) {\n            task.complete(v, null);\n          }, function(c) {\n            task.complete(null, c);\n          });\n        } else {\n          task.complete(null, new TypeError(\"expected thenable\"));\n        }\n      } else {\n        task.complete(null, new TypeError(\"internal: invalid resolve type\"));\n      }\n    }\n  }\n  function transition(p, state, value) {\n    if (p[STATE] === state || p[STATE] !== PENDING) {\n      return;\n    }\n    p[STATE] = state;\n    p[VALUE] = value;\n    return processNextTick(p);\n  }\n  var $jscomp$this$84173391$1 = this;\n  var self = promesa.impl.promise;\n  var root = goog.global;\n  var PENDING = Symbol(\"state/pending\");\n  var RESOLVED = Symbol(\"state/resolved\");\n  var REJECTED = Symbol(\"state/rejected\");\n  var QUEUE = Symbol(\"queue\");\n  var STATE = Symbol(\"state\");\n  var VALUE = Symbol(\"value\");\n  var RESOLVE_TYPE_FLATTEN = Symbol(\"resolve-type/flatten\");\n  var RESOLVE_TYPE_BIND = Symbol(\"resolve-type/bind\");\n  var RESOLVE_TYPE_MAP = Symbol(\"resolve-type/map\");\n  var defaultResolveMapHandler = function(v) {\n    return v;\n  };\n  var defaultResolveBindHandler = function(v) {\n    return self.resolved(v);\n  };\n  var defaultRejectHandler = function(c) {\n    throw c;\n  };\n  var CancellationError = function() {\n    var $jscomp$tmp$error;\n    $jscomp$tmp$error = Error.apply(this, arguments), this.message = $jscomp$tmp$error.message, \"stack\" in $jscomp$tmp$error && (this.stack = $jscomp$tmp$error.stack), this;\n  };\n  $jscomp.inherits(CancellationError, Error);\n  var PromiseImpl = function(val) {\n    this[QUEUE] = [];\n    this[STATE] = PENDING;\n    this[VALUE] = undefined;\n    if (val !== undefined) {\n      transition(this, RESOLVED, val);\n    }\n  };\n  PromiseImpl.prototype.then = function(resolve, reject) {\n    var deferred = new PromiseImpl();\n    var $jscomp$nullish$tmp0;\n    var $jscomp$nullish$tmp1;\n    this[QUEUE].push({type:RESOLVE_TYPE_FLATTEN, resolve:($jscomp$nullish$tmp0 = resolve) != null ? $jscomp$nullish$tmp0 : defaultResolveMapHandler, reject:($jscomp$nullish$tmp1 = reject) != null ? $jscomp$nullish$tmp1 : defaultRejectHandler, complete:completeDeferredFn(deferred)});\n    process(this);\n    return deferred;\n  };\n  PromiseImpl.prototype.catch = function(reject) {\n    return this.then(null, reject);\n  };\n  PromiseImpl.prototype.finally = function(f) {\n    this[QUEUE].push({type:RESOLVE_TYPE_FLATTEN, resolve:function(value) {\n      return f();\n    }, reject:function(cause) {\n      return f();\n    }, complete:function(value, cause) {\n      return null;\n    }});\n    return this;\n  };\n  PromiseImpl.prototype.fmap = function(resolve, reject) {\n    var deferred = new PromiseImpl();\n    var $jscomp$nullish$tmp2;\n    var $jscomp$nullish$tmp3;\n    this[QUEUE].push({type:RESOLVE_TYPE_MAP, resolve:($jscomp$nullish$tmp2 = resolve) != null ? $jscomp$nullish$tmp2 : defaultResolveMapHandler, reject:($jscomp$nullish$tmp3 = reject) != null ? $jscomp$nullish$tmp3 : defaultRejectHandler, complete:completeDeferredFn(deferred)});\n    process(this);\n    return deferred;\n  };\n  PromiseImpl.prototype.fbind = function(resolve, reject) {\n    var deferred = new PromiseImpl();\n    var $jscomp$nullish$tmp4;\n    var $jscomp$nullish$tmp5;\n    this[QUEUE].push({type:RESOLVE_TYPE_BIND, resolve:($jscomp$nullish$tmp4 = resolve) != null ? $jscomp$nullish$tmp4 : defaultResolveBindHandler, reject:($jscomp$nullish$tmp5 = reject) != null ? $jscomp$nullish$tmp5 : defaultRejectHandler, complete:completeDeferredFn(deferred)});\n    process(this);\n    return deferred;\n  };\n  PromiseImpl.prototype.handle = function(fn, resolveType) {\n    var $jscomp$nullish$tmp6;\n    resolveType = ($jscomp$nullish$tmp6 = resolveType) != null ? $jscomp$nullish$tmp6 : RESOLVE_TYPE_MAP;\n    this[QUEUE].push({type:resolveType, resolve:defaultResolveMapHandler, reject:defaultRejectHandler, complete:fn});\n    process(this);\n  };\n  PromiseImpl.prototype.resolve = function(value) {\n    if (this[STATE] === PENDING) {\n      transition(this, RESOLVED, value);\n    }\n    return null;\n  };\n  PromiseImpl.prototype.reject = function(cause) {\n    if (this[STATE] === PENDING) {\n      transition(this, REJECTED, cause);\n    }\n    return null;\n  };\n  PromiseImpl.prototype.isPending = function() {\n    var state = this[STATE];\n    return state === PENDING;\n  };\n  PromiseImpl.prototype.isResolved = function() {\n    var state = this[STATE];\n    return state === RESOLVED;\n  };\n  PromiseImpl.prototype.isRejected = function() {\n    var state = this[STATE];\n    return state === REJECTED;\n  };\n  PromiseImpl.prototype.isCancelled = function() {\n    var state = this[STATE];\n    var value = this[VALUE];\n    return state === REJECTED && isCancellationError(value);\n  };\n  PromiseImpl.prototype.cancel = function() {\n    this.reject(new CancellationError(\"promise cancelled\"));\n  };\n  $jscomp.global.Object.defineProperties(PromiseImpl.prototype, {state:{configurable:true, enumerable:true, get:function() {\n    return this[STATE];\n  }}, value:{configurable:true, enumerable:true, get:function() {\n    return this[VALUE];\n  }}});\n  var nextTick = function() {\n    if (typeof root.Promise === \"function\") {\n      var resolved = Promise.resolve(null);\n      return function queueMicrotaskWithPromise(f, p) {\n        resolved.then(function() {\n          return f(p);\n        });\n      };\n    } else if (typeof root.setImmediate === \"function\") {\n      return root.setImmediate;\n    } else if (typeof root.setTimeout === \"function\") {\n      return function(f, p) {\n        return root.setTimeout(f, 0, p);\n      };\n    } else {\n      return function(f, p) {\n        return f.call($jscomp$this$84173391$1, p);\n      };\n    }\n  }();\n  self.PromiseImpl = PromiseImpl;\n  self.CancellationError = CancellationError;\n  self.isCancellationError = isCancellationError;\n  self.deferred = function() {\n    return new PromiseImpl();\n  };\n  var NULL_PROMISE = new PromiseImpl(null);\n  self.resolved = function resolved(value) {\n    if (value === null) {\n      return NULL_PROMISE;\n    } else {\n      var p = new PromiseImpl();\n      p[STATE] = RESOLVED;\n      p[VALUE] = value;\n      return p;\n    }\n  };\n  self.rejected = function rejected(reason) {\n    var p = new PromiseImpl();\n    p[STATE] = REJECTED;\n    p[VALUE] = reason;\n    return p;\n  };\n  self.all = function all(promises) {\n    return promises.reduce(function(acc, p) {\n      return acc.then(function(results) {\n        return self.coerce(p).fmap(function(v) {\n          results.push(v);\n          return results;\n        });\n      });\n    }, self.resolved([]));\n  };\n  self.coerce = function coerce(promise) {\n    if (promise instanceof PromiseImpl) {\n      return promise;\n    } else if (isThenable(promise)) {\n      var deferred = self.deferred();\n      promise.then(function(v) {\n        deferred.resolve(v);\n      }, function(c) {\n        deferred.reject(c);\n      });\n      return deferred;\n    } else if (promise instanceof Error) {\n      return self.rejected(promise);\n    } else {\n      return self.resolved(promise);\n    }\n  };\n  self.race = function race(promises) {\n    var deferred = self.deferred();\n    promises.forEach(function(p) {\n      self.coerce(p).handle(function(v, c) {\n        if (c) {\n          deferred.reject(c);\n        } else {\n          deferred.resolve(v);\n        }\n      });\n    });\n    return deferred;\n  };\n  self.nextTick = nextTick;\n  self.PENDING = PENDING;\n  self.RESOLVED = RESOLVED;\n  self.REJECTED = REJECTED;\n});\n","~:source","\"use strict\";\n\ngoog.provide(\"promesa.impl.promise\");\ngoog.provide(\"promesa.impl.promise.PromiseImpl\");\ngoog.provide(\"promesa.impl.promise.CancellationError\");\n\ngoog.scope(function() {\n  const self = promesa.impl.promise;\n  const root = goog.global;\n\n  const PENDING = Symbol(\"state/pending\");\n  const RESOLVED = Symbol(\"state/resolved\");\n  const REJECTED = Symbol(\"state/rejected\");\n\n  const QUEUE = Symbol(\"queue\");\n  const STATE = Symbol(\"state\");\n  const VALUE = Symbol(\"value\");\n\n  const RESOLVE_TYPE_FLATTEN = Symbol(\"resolve-type/flatten\");\n  const RESOLVE_TYPE_BIND = Symbol(\"resolve-type/bind\");\n  const RESOLVE_TYPE_MAP = Symbol(\"resolve-type/map\");\n\n  const defaultResolveMapHandler = (v) => v;\n  const defaultResolveBindHandler = (v) => self.resolved(v);\n  const defaultRejectHandler = (c) => {throw c;};\n\n  class CancellationError extends Error {}\n\n  class PromiseImpl {\n    constructor (val) {\n      this[QUEUE] = [];\n      this[STATE] = PENDING;\n      this[VALUE] = undefined;\n\n      if (val !== undefined) {\n        transition(this, RESOLVED, val);\n      }\n    }\n\n    get state () {\n      return this[STATE];\n    }\n\n    get value () {\n      return this[VALUE];\n    }\n\n    then (resolve, reject) {\n      const deferred = new PromiseImpl();\n\n      this[QUEUE].push({\n        type: RESOLVE_TYPE_FLATTEN,\n        resolve: resolve ?? defaultResolveMapHandler,\n        reject: reject ?? defaultRejectHandler,\n        complete: completeDeferredFn(deferred)\n      });\n\n      // console.log(\"then\",\n      //             \"uid:\", goog.getUid(this),\n      //             \"return-uid:\", goog.getUid(deferred),\n      //             \"state:\", this[STATE],\n      //             \"value:\", fmtValue(this[VALUE]));\n\n      process(this);\n      return deferred;\n    }\n\n    catch (reject) {\n      return this.then(null, reject);\n    }\n\n    finally (f) {\n      this[QUEUE].push({\n        type: RESOLVE_TYPE_FLATTEN,\n        resolve: (value) => f(),\n        reject: (cause) => f(),\n        complete: (value, cause) => null\n      });\n\n      return this;\n    }\n\n    fmap (resolve, reject) {\n      const deferred = new PromiseImpl();\n\n      this[QUEUE].push({\n        type: RESOLVE_TYPE_MAP,\n        resolve: resolve ?? defaultResolveMapHandler,\n        reject: reject ?? defaultRejectHandler,\n        complete: completeDeferredFn(deferred)\n      });\n\n      // console.log(\"fmap\",\n      //             \"uid:\", goog.getUid(this),\n      //             \"return-uid:\", goog.getUid(deferred),\n      //             \"state:\", this[STATE],\n      //             \"value:\", fmtValue(this[VALUE]));\n\n      process(this);\n      return deferred;\n    }\n\n    fbind (resolve, reject) {\n      const deferred = new PromiseImpl();\n\n      this[QUEUE].push({\n        type: RESOLVE_TYPE_BIND,\n        resolve: resolve ?? defaultResolveBindHandler,\n        reject: reject ?? defaultRejectHandler,\n        complete: completeDeferredFn(deferred)\n      });\n\n      // console.log(\"fbind\",\n      //             \"uid:\", goog.getUid(this),\n      //             \"return-uid:\", goog.getUid(deferred),\n      //             \"state:\", this[STATE],\n      //             \"value:\", fmtValue(this[VALUE]));\n\n      process(this);\n      return deferred;\n    }\n\n    handle (fn, resolveType) {\n      resolveType = resolveType ?? RESOLVE_TYPE_MAP;\n\n      this[QUEUE].push({\n        type: resolveType,\n        resolve: defaultResolveMapHandler,\n        reject: defaultRejectHandler,\n        complete: fn\n      });\n\n      process(this);\n    }\n\n    // Deferred Methods\n\n    resolve(value) {\n      if (this[STATE] === PENDING) {\n        // console.log(\":: [deferred:resolve]\",\n        //             \"uid:\", goog.getUid(this),\n        //             \"value:\", fmtValue(value));\n\n        transition(this, RESOLVED, value);\n      }\n      return null;\n    }\n\n    reject(cause) {\n      if (this[STATE] === PENDING) {\n        // console.log(\":: [deferred:reject]\",\n        //             \"uid:\", goog.getUid(this),\n        //             \"value:\", fmtValue(cause));\n        transition(this, REJECTED, cause);\n      }\n      return null;\n    }\n\n    isPending() {\n      const state = this[STATE];\n      return state === PENDING;\n    }\n\n    isResolved() {\n      const state = this[STATE];\n      return state === RESOLVED;\n    }\n\n    isRejected() {\n      const state = this[STATE];\n      return state === REJECTED;\n    }\n\n    isCancelled() {\n      const state = this[STATE];\n      const value = this[VALUE];\n      return (state === REJECTED && isCancellationError(value));\n    }\n\n    cancel() {\n      this.reject(new CancellationError(\"promise cancelled\"));\n    }\n  }\n\n  const nextTick = (() => {\n    if (typeof root.Promise === \"function\") {\n      const resolved = Promise.resolve(null);\n      return function queueMicrotaskWithPromise(f, p) {\n        resolved.then(() => f(p));\n      };\n    } else if (typeof root.setImmediate === \"function\") {\n      return root.setImmediate;\n    } else if (typeof root.setTimeout === \"function\") {\n      return (f, p) => root.setTimeout(f, 0, p);\n    } else {\n      // console.error(\"No nextTick. How we gonna do this?\");\n      return (f, p) => f.call(this, p);\n    }\n  })();\n\n  function isCancellationError(v) {\n    return v instanceof CancellationError;\n  }\n\n  function fmtValue (o) {\n    if (isThenable(o)) {\n      return `<PROMISE:${goog.getUid(o)}>`;\n    } else if (o instanceof Error) {\n      return `<EXCEPTION:'${o.message}'>`;\n    } else if (o === null || o === undefined) {\n      return `${o}`;\n    } else if (typeof o === \"function\") {\n      return `<FN:${goog.getUid(o)}>`;\n    } else {\n      return `${o.toString()}`;\n    }\n  }\n\n  function isSome(o) {\n    return o !== null && o !== undefined;\n  }\n\n  function isFunction (o) {\n    return typeof o === \"function\";\n  }\n\n  function isThenable (o) {\n    if (goog.isObject(o)) {\n      const thenFn = o.then;\n      return isFunction(thenFn);\n    } else {\n      return false;\n    }\n  }\n\n  function constantly(v) {\n    return () => v;\n  }\n\n  function identity (v) {\n    return v;\n  }\n\n  function isPromiseImpl (v) {\n    return v instanceof PromiseImpl;\n  }\n\n  function completeDeferredFn(deferred) {\n    return (value, cause) => {\n      if (cause) {\n        deferred.reject(cause);\n      } else {\n        deferred.resolve(value);\n      }\n    };\n  }\n\n  function process(p) {\n    if (p[STATE] === PENDING) return;\n    nextTick(processNextTick, p);\n    return p;\n  }\n\n  function processNextTick(p) {\n    if (p[QUEUE].length === 0) return;\n\n    const state = p[STATE];\n    const value = p[VALUE];\n    let task, rvalue, rcause;\n\n    // console.log(\":: process:\",\n    //             \"uid:\", goog.getUid(p),\n    //             \"queue size:\", p[QUEUE].length,\n    //             \"state:\", p[STATE],\n    //             \"value:\", fmtValue(p[VALUE]));\n\n    while (p[QUEUE].length) {\n      task = p[QUEUE].shift();\n\n      // console.log(\":: process-task:\",\n      //             \"deferred-uid:\", task.deferred ? goog.getUid(task.deferred) : null,\n      //             \"type:\", task.type);\n\n      try {\n        if (state === RESOLVED) {\n          rvalue = task.resolve(value)\n        } else if (state === REJECTED) {\n          rvalue = task.reject(value)\n        } else {\n          rcause = new TypeError(\"invalid state\");\n        }\n      } catch (e) {\n        rcause = e;\n      }\n\n      resolveTask(task, rvalue, rcause);\n    }\n  }\n\n  function resolveTask(task, value, cause) {\n\n    if (task.complete === undefined) return;\n\n    if (cause) {\n      task.complete(null, cause);\n    } else {\n      if (task.type === RESOLVE_TYPE_MAP) {\n        // console.trace(task);\n        task.complete(value, null);\n      } else if (task.type === RESOLVE_TYPE_FLATTEN) {\n        if (isPromiseImpl(value)) {\n          value.handle((v, c) => {\n            resolveTask(task, v, c);\n          });\n        } else if (isThenable(value)) {\n          value.then((v) => {\n            resolveTask(task, v, null);\n          }, (c) => {\n            resolveTask(task, null, c);\n          });\n        } else {\n          task.complete(value, null);\n        }\n      } else if (task.type === RESOLVE_TYPE_BIND) {\n        if (isPromiseImpl(value)) {\n          value.handle((v, c) => {\n            task.complete(v, c);\n          });\n        } else if (isThenable(value)) {\n          value.then((v) => {\n            task.complete(v, null);\n          }, (c) => {\n            task.complete(null, c);\n          });\n        } else {\n          task.complete(null, new TypeError(\"expected thenable\"));\n        }\n      } else {\n        task.complete(null, new TypeError(\"internal: invalid resolve type\"));\n      }\n    }\n  }\n\n  function transition(p, state, value) {\n    // console.log(\">> transition\",\n    //             \"uid:\", goog.getUid(p),\n    //             \"from-state:\", p[STATE],\n    //             \"to-state:\", state,\n    //             \"value:\", fmtValue(value),\n    //             \"queue:\", p[QUEUE].length);\n\n    if (p[STATE] === state ||\n        p[STATE] !== PENDING) {\n      return;\n    }\n\n    p[STATE] = state;\n    p[VALUE] = value;\n\n    return processNextTick(p);\n  }\n\n  self.PromiseImpl = PromiseImpl;\n  self.CancellationError = CancellationError;\n  self.isCancellationError = isCancellationError;\n\n  self.deferred = () => {\n    return new PromiseImpl();\n  };\n\n  const NULL_PROMISE = new PromiseImpl(null);\n\n  self.resolved = function resolved (value) {\n    if (value === null) {\n      return NULL_PROMISE;\n    } else {\n      const p = new PromiseImpl();\n      p[STATE] = RESOLVED;\n      p[VALUE] = value;\n      // console.log(\"++ [resolved]\", \"uid:\", goog.getUid(p), \"value:\", value);\n\n      return p;\n    }\n  };\n\n  self.rejected = function rejected (reason) {\n    const p = new PromiseImpl();\n    p[STATE] = REJECTED;\n    p[VALUE] = reason;\n\n    // console.log(\"++ [rejected]\", \"uid:\", goog.getUid(p), \"value:\", fmtValue(reason));\n\n    return p;\n  };\n\n  self.all = function all (promises) {\n    return promises.reduce((acc, p) => {\n      return acc.then((results) => {\n        return self.coerce(p).fmap((v) => {\n          results.push(v);\n          return results;\n        });\n      });\n    }, self.resolved([]));\n  };\n\n  self.coerce = function coerce (promise) {\n    if (promise instanceof PromiseImpl) {\n      return promise;\n    } else if (isThenable(promise)) {\n      const deferred = self.deferred();\n      promise.then((v) => {\n        deferred.resolve(v);\n      }, (c) => {\n        deferred.reject(c);\n      });\n      return deferred;\n    } else if (promise instanceof Error) {\n      return self.rejected(promise);\n    } else {\n      return self.resolved(promise);\n    }\n  };\n\n  self.race = function race (promises) {\n    const deferred = self.deferred();\n\n    promises.forEach((p) => {\n      self.coerce(p).handle((v, c) => {\n        if (c) {\n          deferred.reject(c);\n        } else {\n          deferred.resolve(v);\n        }\n      });\n    });\n\n    return deferred;\n  };\n\n  self.nextTick = nextTick;\n\n  self.PENDING = PENDING;\n  self.RESOLVED = RESOLVED;\n  self.REJECTED = REJECTED;\n});\n","~:compiled-at",1738521168733,"~:source-map-json","{\n\"version\":3,\n\"file\":\"promesa.impl.promise.js\",\n\"lineCount\":339,\n\"mappings\":\"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\",\n\"sources\":[\"promesa/impl/promise.js\"],\n\"sourcesContent\":[\"\\\"use strict\\\";\\n\\ngoog.provide(\\\"promesa.impl.promise\\\");\\ngoog.provide(\\\"promesa.impl.promise.PromiseImpl\\\");\\ngoog.provide(\\\"promesa.impl.promise.CancellationError\\\");\\n\\ngoog.scope(function() {\\n  const self = promesa.impl.promise;\\n  const root = goog.global;\\n\\n  const PENDING = Symbol(\\\"state/pending\\\");\\n  const RESOLVED = Symbol(\\\"state/resolved\\\");\\n  const REJECTED = Symbol(\\\"state/rejected\\\");\\n\\n  const QUEUE = Symbol(\\\"queue\\\");\\n  const STATE = Symbol(\\\"state\\\");\\n  const VALUE = Symbol(\\\"value\\\");\\n\\n  const RESOLVE_TYPE_FLATTEN = Symbol(\\\"resolve-type/flatten\\\");\\n  const RESOLVE_TYPE_BIND = Symbol(\\\"resolve-type/bind\\\");\\n  const RESOLVE_TYPE_MAP = Symbol(\\\"resolve-type/map\\\");\\n\\n  const defaultResolveMapHandler = (v) => v;\\n  const defaultResolveBindHandler = (v) => self.resolved(v);\\n  const defaultRejectHandler = (c) => {throw c;};\\n\\n  class CancellationError extends Error {}\\n\\n  class PromiseImpl {\\n    constructor (val) {\\n      this[QUEUE] = [];\\n      this[STATE] = PENDING;\\n      this[VALUE] = undefined;\\n\\n      if (val !== undefined) {\\n        transition(this, RESOLVED, val);\\n      }\\n    }\\n\\n    get state () {\\n      return this[STATE];\\n    }\\n\\n    get value () {\\n      return this[VALUE];\\n    }\\n\\n    then (resolve, reject) {\\n      const deferred = new PromiseImpl();\\n\\n      this[QUEUE].push({\\n        type: RESOLVE_TYPE_FLATTEN,\\n        resolve: resolve ?? defaultResolveMapHandler,\\n        reject: reject ?? defaultRejectHandler,\\n        complete: completeDeferredFn(deferred)\\n      });\\n\\n      // console.log(\\\"then\\\",\\n      //             \\\"uid:\\\", goog.getUid(this),\\n      //             \\\"return-uid:\\\", goog.getUid(deferred),\\n      //             \\\"state:\\\", this[STATE],\\n      //             \\\"value:\\\", fmtValue(this[VALUE]));\\n\\n      process(this);\\n      return deferred;\\n    }\\n\\n    catch (reject) {\\n      return this.then(null, reject);\\n    }\\n\\n    finally (f) {\\n      this[QUEUE].push({\\n        type: RESOLVE_TYPE_FLATTEN,\\n        resolve: (value) => f(),\\n        reject: (cause) => f(),\\n        complete: (value, cause) => null\\n      });\\n\\n      return this;\\n    }\\n\\n    fmap (resolve, reject) {\\n      const deferred = new PromiseImpl();\\n\\n      this[QUEUE].push({\\n        type: RESOLVE_TYPE_MAP,\\n        resolve: resolve ?? defaultResolveMapHandler,\\n        reject: reject ?? defaultRejectHandler,\\n        complete: completeDeferredFn(deferred)\\n      });\\n\\n      // console.log(\\\"fmap\\\",\\n      //             \\\"uid:\\\", goog.getUid(this),\\n      //             \\\"return-uid:\\\", goog.getUid(deferred),\\n      //             \\\"state:\\\", this[STATE],\\n      //             \\\"value:\\\", fmtValue(this[VALUE]));\\n\\n      process(this);\\n      return deferred;\\n    }\\n\\n    fbind (resolve, reject) {\\n      const deferred = new PromiseImpl();\\n\\n      this[QUEUE].push({\\n        type: RESOLVE_TYPE_BIND,\\n        resolve: resolve ?? defaultResolveBindHandler,\\n        reject: reject ?? defaultRejectHandler,\\n        complete: completeDeferredFn(deferred)\\n      });\\n\\n      // console.log(\\\"fbind\\\",\\n      //             \\\"uid:\\\", goog.getUid(this),\\n      //             \\\"return-uid:\\\", goog.getUid(deferred),\\n      //             \\\"state:\\\", this[STATE],\\n      //             \\\"value:\\\", fmtValue(this[VALUE]));\\n\\n      process(this);\\n      return deferred;\\n    }\\n\\n    handle (fn, resolveType) {\\n      resolveType = resolveType ?? RESOLVE_TYPE_MAP;\\n\\n      this[QUEUE].push({\\n        type: resolveType,\\n        resolve: defaultResolveMapHandler,\\n        reject: defaultRejectHandler,\\n        complete: fn\\n      });\\n\\n      process(this);\\n    }\\n\\n    // Deferred Methods\\n\\n    resolve(value) {\\n      if (this[STATE] === PENDING) {\\n        // console.log(\\\":: [deferred:resolve]\\\",\\n        //             \\\"uid:\\\", goog.getUid(this),\\n        //             \\\"value:\\\", fmtValue(value));\\n\\n        transition(this, RESOLVED, value);\\n      }\\n      return null;\\n    }\\n\\n    reject(cause) {\\n      if (this[STATE] === PENDING) {\\n        // console.log(\\\":: [deferred:reject]\\\",\\n        //             \\\"uid:\\\", goog.getUid(this),\\n        //             \\\"value:\\\", fmtValue(cause));\\n        transition(this, REJECTED, cause);\\n      }\\n      return null;\\n    }\\n\\n    isPending() {\\n      const state = this[STATE];\\n      return state === PENDING;\\n    }\\n\\n    isResolved() {\\n      const state = this[STATE];\\n      return state === RESOLVED;\\n    }\\n\\n    isRejected() {\\n      const state = this[STATE];\\n      return state === REJECTED;\\n    }\\n\\n    isCancelled() {\\n      const state = this[STATE];\\n      const value = this[VALUE];\\n      return (state === REJECTED && isCancellationError(value));\\n    }\\n\\n    cancel() {\\n      this.reject(new CancellationError(\\\"promise cancelled\\\"));\\n    }\\n  }\\n\\n  const nextTick = (() => {\\n    if (typeof root.Promise === \\\"function\\\") {\\n      const resolved = Promise.resolve(null);\\n      return function queueMicrotaskWithPromise(f, p) {\\n        resolved.then(() => f(p));\\n      };\\n    } else if (typeof root.setImmediate === \\\"function\\\") {\\n      return root.setImmediate;\\n    } else if (typeof root.setTimeout === \\\"function\\\") {\\n      return (f, p) => root.setTimeout(f, 0, p);\\n    } else {\\n      // console.error(\\\"No nextTick. How we gonna do this?\\\");\\n      return (f, p) => f.call(this, p);\\n    }\\n  })();\\n\\n  function isCancellationError(v) {\\n    return v instanceof CancellationError;\\n  }\\n\\n  function fmtValue (o) {\\n    if (isThenable(o)) {\\n      return `<PROMISE:${goog.getUid(o)}>`;\\n    } else if (o instanceof Error) {\\n      return `<EXCEPTION:'${o.message}'>`;\\n    } else if (o === null || o === undefined) {\\n      return `${o}`;\\n    } else if (typeof o === \\\"function\\\") {\\n      return `<FN:${goog.getUid(o)}>`;\\n    } else {\\n      return `${o.toString()}`;\\n    }\\n  }\\n\\n  function isSome(o) {\\n    return o !== null && o !== undefined;\\n  }\\n\\n  function isFunction (o) {\\n    return typeof o === \\\"function\\\";\\n  }\\n\\n  function isThenable (o) {\\n    if (goog.isObject(o)) {\\n      const thenFn = o.then;\\n      return isFunction(thenFn);\\n    } else {\\n      return false;\\n    }\\n  }\\n\\n  function constantly(v) {\\n    return () => v;\\n  }\\n\\n  function identity (v) {\\n    return v;\\n  }\\n\\n  function isPromiseImpl (v) {\\n    return v instanceof PromiseImpl;\\n  }\\n\\n  function completeDeferredFn(deferred) {\\n    return (value, cause) => {\\n      if (cause) {\\n        deferred.reject(cause);\\n      } else {\\n        deferred.resolve(value);\\n      }\\n    };\\n  }\\n\\n  function process(p) {\\n    if (p[STATE] === PENDING) return;\\n    nextTick(processNextTick, p);\\n    return p;\\n  }\\n\\n  function processNextTick(p) {\\n    if (p[QUEUE].length === 0) return;\\n\\n    const state = p[STATE];\\n    const value = p[VALUE];\\n    let task, rvalue, rcause;\\n\\n    // console.log(\\\":: process:\\\",\\n    //             \\\"uid:\\\", goog.getUid(p),\\n    //             \\\"queue size:\\\", p[QUEUE].length,\\n    //             \\\"state:\\\", p[STATE],\\n    //             \\\"value:\\\", fmtValue(p[VALUE]));\\n\\n    while (p[QUEUE].length) {\\n      task = p[QUEUE].shift();\\n\\n      // console.log(\\\":: process-task:\\\",\\n      //             \\\"deferred-uid:\\\", task.deferred ? goog.getUid(task.deferred) : null,\\n      //             \\\"type:\\\", task.type);\\n\\n      try {\\n        if (state === RESOLVED) {\\n          rvalue = task.resolve(value)\\n        } else if (state === REJECTED) {\\n          rvalue = task.reject(value)\\n        } else {\\n          rcause = new TypeError(\\\"invalid state\\\");\\n        }\\n      } catch (e) {\\n        rcause = e;\\n      }\\n\\n      resolveTask(task, rvalue, rcause);\\n    }\\n  }\\n\\n  function resolveTask(task, value, cause) {\\n\\n    if (task.complete === undefined) return;\\n\\n    if (cause) {\\n      task.complete(null, cause);\\n    } else {\\n      if (task.type === RESOLVE_TYPE_MAP) {\\n        // console.trace(task);\\n        task.complete(value, null);\\n      } else if (task.type === RESOLVE_TYPE_FLATTEN) {\\n        if (isPromiseImpl(value)) {\\n          value.handle((v, c) => {\\n            resolveTask(task, v, c);\\n          });\\n        } else if (isThenable(value)) {\\n          value.then((v) => {\\n            resolveTask(task, v, null);\\n          }, (c) => {\\n            resolveTask(task, null, c);\\n          });\\n        } else {\\n          task.complete(value, null);\\n        }\\n      } else if (task.type === RESOLVE_TYPE_BIND) {\\n        if (isPromiseImpl(value)) {\\n          value.handle((v, c) => {\\n            task.complete(v, c);\\n          });\\n        } else if (isThenable(value)) {\\n          value.then((v) => {\\n            task.complete(v, null);\\n          }, (c) => {\\n            task.complete(null, c);\\n          });\\n        } else {\\n          task.complete(null, new TypeError(\\\"expected thenable\\\"));\\n        }\\n      } else {\\n        task.complete(null, new TypeError(\\\"internal: invalid resolve type\\\"));\\n      }\\n    }\\n  }\\n\\n  function transition(p, state, value) {\\n    // console.log(\\\">> transition\\\",\\n    //             \\\"uid:\\\", goog.getUid(p),\\n    //             \\\"from-state:\\\", p[STATE],\\n    //             \\\"to-state:\\\", state,\\n    //             \\\"value:\\\", fmtValue(value),\\n    //             \\\"queue:\\\", p[QUEUE].length);\\n\\n    if (p[STATE] === state ||\\n        p[STATE] !== PENDING) {\\n      return;\\n    }\\n\\n    p[STATE] = state;\\n    p[VALUE] = value;\\n\\n    return processNextTick(p);\\n  }\\n\\n  self.PromiseImpl = PromiseImpl;\\n  self.CancellationError = CancellationError;\\n  self.isCancellationError = isCancellationError;\\n\\n  self.deferred = () => {\\n    return new PromiseImpl();\\n  };\\n\\n  const NULL_PROMISE = new PromiseImpl(null);\\n\\n  self.resolved = function resolved (value) {\\n    if (value === null) {\\n      return NULL_PROMISE;\\n    } else {\\n      const p = new PromiseImpl();\\n      p[STATE] = RESOLVED;\\n      p[VALUE] = value;\\n      // console.log(\\\"++ [resolved]\\\", \\\"uid:\\\", goog.getUid(p), \\\"value:\\\", value);\\n\\n      return p;\\n    }\\n  };\\n\\n  self.rejected = function rejected (reason) {\\n    const p = new PromiseImpl();\\n    p[STATE] = REJECTED;\\n    p[VALUE] = reason;\\n\\n    // console.log(\\\"++ [rejected]\\\", \\\"uid:\\\", goog.getUid(p), \\\"value:\\\", fmtValue(reason));\\n\\n    return p;\\n  };\\n\\n  self.all = function all (promises) {\\n    return promises.reduce((acc, p) => {\\n      return acc.then((results) => {\\n        return self.coerce(p).fmap((v) => {\\n          results.push(v);\\n          return results;\\n        });\\n      });\\n    }, self.resolved([]));\\n  };\\n\\n  self.coerce = function coerce (promise) {\\n    if (promise instanceof PromiseImpl) {\\n      return promise;\\n    } else if (isThenable(promise)) {\\n      const deferred = self.deferred();\\n      promise.then((v) => {\\n        deferred.resolve(v);\\n      }, (c) => {\\n        deferred.reject(c);\\n      });\\n      return deferred;\\n    } else if (promise instanceof Error) {\\n      return self.rejected(promise);\\n    } else {\\n      return self.resolved(promise);\\n    }\\n  };\\n\\n  self.race = function race (promises) {\\n    const deferred = self.deferred();\\n\\n    promises.forEach((p) => {\\n      self.coerce(p).handle((v, c) => {\\n        if (c) {\\n          deferred.reject(c);\\n        } else {\\n          deferred.resolve(v);\\n        }\\n      });\\n    });\\n\\n    return deferred;\\n  };\\n\\n  self.nextTick = nextTick;\\n\\n  self.PENDING = PENDING;\\n  self.RESOLVED = RESOLVED;\\n  self.REJECTED = REJECTED;\\n});\\n\"],\n\"names\":[\"goog\",\"provide\",\"scope\",\"isCancellationError\",\"v\",\"CancellationError\",\"fmtValue\",\"o\",\"isThenable\",\"getUid\",\"Error\",\"message\",\"undefined\",\"toString\",\"isSome\",\"isFunction\",\"isObject\",\"thenFn\",\"then\",\"constantly\",\"identity\",\"isPromiseImpl\",\"PromiseImpl\",\"completeDeferredFn\",\"deferred\",\"value\",\"cause\",\"reject\",\"resolve\",\"process\",\"p\",\"STATE\",\"PENDING\",\"nextTick\",\"processNextTick\",\"QUEUE\",\"length\",\"state\",\"VALUE\",\"task\",\"rvalue\",\"rcause\",\"shift\",\"RESOLVED\",\"REJECTED\",\"TypeError\",\"e\",\"resolveTask\",\"complete\",\"type\",\"RESOLVE_TYPE_MAP\",\"RESOLVE_TYPE_FLATTEN\",\"handle\",\"c\",\"RESOLVE_TYPE_BIND\",\"transition\",\"self\",\"promesa\",\"impl\",\"promise\",\"root\",\"global\",\"Symbol\",\"defaultResolveMapHandler\",\"defaultResolveBindHandler\",\"resolved\",\"defaultRejectHandler\",\"constructor\",\"val\",\"push\",\"catch\",\"finally\",\"f\",\"fmap\",\"fbind\",\"fn\",\"resolveType\",\"isPending\",\"isResolved\",\"isRejected\",\"isCancelled\",\"cancel\",\"Promise\",\"queueMicrotaskWithPromise\",\"setImmediate\",\"setTimeout\",\"call\",\"self.deferred\",\"NULL_PROMISE\",\"self.resolved\",\"rejected\",\"self.rejected\",\"reason\",\"all\",\"self.all\",\"promises\",\"reduce\",\"acc\",\"results\",\"coerce\",\"self.coerce\",\"race\",\"self.race\",\"forEach\"]\n}\n"]