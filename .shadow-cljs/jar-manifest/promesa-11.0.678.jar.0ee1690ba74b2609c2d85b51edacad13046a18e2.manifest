["^ ","~:resources",[["^ ","~:cache-key",["0ee1690ba74b2609c2d85b51edacad13046a18e2"],"~:goog-provides",["~#set",["~$promesa.impl.promise","~$promesa.impl.promise.PromiseImpl","~$promesa.impl.promise.CancellationError"]],"~:output-name","promesa.impl.promise.js","~:resource-id",["~:shadow.build.classpath/resource","promesa/impl/promise.js"],"~:resource-name","promesa/impl/promise.js","~:type","~:goog","~:source","\"use strict\";\n\ngoog.provide(\"promesa.impl.promise\");\ngoog.provide(\"promesa.impl.promise.PromiseImpl\");\ngoog.provide(\"promesa.impl.promise.CancellationError\");\n\ngoog.scope(function() {\n  const self = promesa.impl.promise;\n  const root = goog.global;\n\n  const PENDING = Symbol(\"state/pending\");\n  const RESOLVED = Symbol(\"state/resolved\");\n  const REJECTED = Symbol(\"state/rejected\");\n\n  const QUEUE = Symbol(\"queue\");\n  const STATE = Symbol(\"state\");\n  const VALUE = Symbol(\"value\");\n\n  const RESOLVE_TYPE_FLATTEN = Symbol(\"resolve-type/flatten\");\n  const RESOLVE_TYPE_BIND = Symbol(\"resolve-type/bind\");\n  const RESOLVE_TYPE_MAP = Symbol(\"resolve-type/map\");\n\n  const defaultResolveMapHandler = (v) => v;\n  const defaultResolveBindHandler = (v) => self.resolved(v);\n  const defaultRejectHandler = (c) => {throw c;};\n\n  class CancellationError extends Error {}\n\n  class PromiseImpl {\n    constructor (val) {\n      this[QUEUE] = [];\n      this[STATE] = PENDING;\n      this[VALUE] = undefined;\n\n      if (val !== undefined) {\n        transition(this, RESOLVED, val);\n      }\n    }\n\n    get state () {\n      return this[STATE];\n    }\n\n    get value () {\n      return this[VALUE];\n    }\n\n    then (resolve, reject) {\n      const deferred = new PromiseImpl();\n\n      this[QUEUE].push({\n        type: RESOLVE_TYPE_FLATTEN,\n        resolve: resolve ?? defaultResolveMapHandler,\n        reject: reject ?? defaultRejectHandler,\n        complete: completeDeferredFn(deferred)\n      });\n\n      // console.log(\"then\",\n      //             \"uid:\", goog.getUid(this),\n      //             \"return-uid:\", goog.getUid(deferred),\n      //             \"state:\", this[STATE],\n      //             \"value:\", fmtValue(this[VALUE]));\n\n      process(this);\n      return deferred;\n    }\n\n    catch (reject) {\n      return this.then(null, reject);\n    }\n\n    finally (f) {\n      this[QUEUE].push({\n        type: RESOLVE_TYPE_FLATTEN,\n        resolve: (value) => f(),\n        reject: (cause) => f(),\n        complete: (value, cause) => null\n      });\n\n      return this;\n    }\n\n    fmap (resolve, reject) {\n      const deferred = new PromiseImpl();\n\n      this[QUEUE].push({\n        type: RESOLVE_TYPE_MAP,\n        resolve: resolve ?? defaultResolveMapHandler,\n        reject: reject ?? defaultRejectHandler,\n        complete: completeDeferredFn(deferred)\n      });\n\n      // console.log(\"fmap\",\n      //             \"uid:\", goog.getUid(this),\n      //             \"return-uid:\", goog.getUid(deferred),\n      //             \"state:\", this[STATE],\n      //             \"value:\", fmtValue(this[VALUE]));\n\n      process(this);\n      return deferred;\n    }\n\n    fbind (resolve, reject) {\n      const deferred = new PromiseImpl();\n\n      this[QUEUE].push({\n        type: RESOLVE_TYPE_BIND,\n        resolve: resolve ?? defaultResolveBindHandler,\n        reject: reject ?? defaultRejectHandler,\n        complete: completeDeferredFn(deferred)\n      });\n\n      // console.log(\"fbind\",\n      //             \"uid:\", goog.getUid(this),\n      //             \"return-uid:\", goog.getUid(deferred),\n      //             \"state:\", this[STATE],\n      //             \"value:\", fmtValue(this[VALUE]));\n\n      process(this);\n      return deferred;\n    }\n\n    handle (fn, resolveType) {\n      resolveType = resolveType ?? RESOLVE_TYPE_MAP;\n\n      this[QUEUE].push({\n        type: resolveType,\n        resolve: defaultResolveMapHandler,\n        reject: defaultRejectHandler,\n        complete: fn\n      });\n\n      process(this);\n    }\n\n    // Deferred Methods\n\n    resolve(value) {\n      if (this[STATE] === PENDING) {\n        // console.log(\":: [deferred:resolve]\",\n        //             \"uid:\", goog.getUid(this),\n        //             \"value:\", fmtValue(value));\n\n        transition(this, RESOLVED, value);\n      }\n      return null;\n    }\n\n    reject(cause) {\n      if (this[STATE] === PENDING) {\n        // console.log(\":: [deferred:reject]\",\n        //             \"uid:\", goog.getUid(this),\n        //             \"value:\", fmtValue(cause));\n        transition(this, REJECTED, cause);\n      }\n      return null;\n    }\n\n    isPending() {\n      const state = this[STATE];\n      return state === PENDING;\n    }\n\n    isResolved() {\n      const state = this[STATE];\n      return state === RESOLVED;\n    }\n\n    isRejected() {\n      const state = this[STATE];\n      return state === REJECTED;\n    }\n\n    isCancelled() {\n      const state = this[STATE];\n      const value = this[VALUE];\n      return (state === REJECTED && isCancellationError(value));\n    }\n\n    cancel() {\n      this.reject(new CancellationError(\"promise cancelled\"));\n    }\n  }\n\n  const nextTick = (() => {\n    if (typeof root.Promise === \"function\") {\n      const resolved = Promise.resolve(null);\n      return function queueMicrotaskWithPromise(f, p) {\n        resolved.then(() => f(p));\n      };\n    } else if (typeof root.setImmediate === \"function\") {\n      return root.setImmediate;\n    } else if (typeof root.setTimeout === \"function\") {\n      return (f, p) => root.setTimeout(f, 0, p);\n    } else {\n      // console.error(\"No nextTick. How we gonna do this?\");\n      return (f, p) => f.call(this, p);\n    }\n  })();\n\n  function isCancellationError(v) {\n    return v instanceof CancellationError;\n  }\n\n  function fmtValue (o) {\n    if (isThenable(o)) {\n      return `<PROMISE:${goog.getUid(o)}>`;\n    } else if (o instanceof Error) {\n      return `<EXCEPTION:'${o.message}'>`;\n    } else if (o === null || o === undefined) {\n      return `${o}`;\n    } else if (typeof o === \"function\") {\n      return `<FN:${goog.getUid(o)}>`;\n    } else {\n      return `${o.toString()}`;\n    }\n  }\n\n  function isSome(o) {\n    return o !== null && o !== undefined;\n  }\n\n  function isFunction (o) {\n    return typeof o === \"function\";\n  }\n\n  function isThenable (o) {\n    if (goog.isObject(o)) {\n      const thenFn = o.then;\n      return isFunction(thenFn);\n    } else {\n      return false;\n    }\n  }\n\n  function constantly(v) {\n    return () => v;\n  }\n\n  function identity (v) {\n    return v;\n  }\n\n  function isPromiseImpl (v) {\n    return v instanceof PromiseImpl;\n  }\n\n  function completeDeferredFn(deferred) {\n    return (value, cause) => {\n      if (cause) {\n        deferred.reject(cause);\n      } else {\n        deferred.resolve(value);\n      }\n    };\n  }\n\n  function process(p) {\n    if (p[STATE] === PENDING) return;\n    nextTick(processNextTick, p);\n    return p;\n  }\n\n  function processNextTick(p) {\n    if (p[QUEUE].length === 0) return;\n\n    const state = p[STATE];\n    const value = p[VALUE];\n    let task, rvalue, rcause;\n\n    // console.log(\":: process:\",\n    //             \"uid:\", goog.getUid(p),\n    //             \"queue size:\", p[QUEUE].length,\n    //             \"state:\", p[STATE],\n    //             \"value:\", fmtValue(p[VALUE]));\n\n    while (p[QUEUE].length) {\n      task = p[QUEUE].shift();\n\n      // console.log(\":: process-task:\",\n      //             \"deferred-uid:\", task.deferred ? goog.getUid(task.deferred) : null,\n      //             \"type:\", task.type);\n\n      try {\n        if (state === RESOLVED) {\n          rvalue = task.resolve(value)\n        } else if (state === REJECTED) {\n          rvalue = task.reject(value)\n        } else {\n          rcause = new TypeError(\"invalid state\");\n        }\n      } catch (e) {\n        rcause = e;\n      }\n\n      resolveTask(task, rvalue, rcause);\n    }\n  }\n\n  function resolveTask(task, value, cause) {\n\n    if (task.complete === undefined) return;\n\n    if (cause) {\n      task.complete(null, cause);\n    } else {\n      if (task.type === RESOLVE_TYPE_MAP) {\n        // console.trace(task);\n        task.complete(value, null);\n      } else if (task.type === RESOLVE_TYPE_FLATTEN) {\n        if (isPromiseImpl(value)) {\n          value.handle((v, c) => {\n            resolveTask(task, v, c);\n          });\n        } else if (isThenable(value)) {\n          value.then((v) => {\n            resolveTask(task, v, null);\n          }, (c) => {\n            resolveTask(task, null, c);\n          });\n        } else {\n          task.complete(value, null);\n        }\n      } else if (task.type === RESOLVE_TYPE_BIND) {\n        if (isPromiseImpl(value)) {\n          value.handle((v, c) => {\n            task.complete(v, c);\n          });\n        } else if (isThenable(value)) {\n          value.then((v) => {\n            task.complete(v, null);\n          }, (c) => {\n            task.complete(null, c);\n          });\n        } else {\n          task.complete(null, new TypeError(\"expected thenable\"));\n        }\n      } else {\n        task.complete(null, new TypeError(\"internal: invalid resolve type\"));\n      }\n    }\n  }\n\n  function transition(p, state, value) {\n    // console.log(\">> transition\",\n    //             \"uid:\", goog.getUid(p),\n    //             \"from-state:\", p[STATE],\n    //             \"to-state:\", state,\n    //             \"value:\", fmtValue(value),\n    //             \"queue:\", p[QUEUE].length);\n\n    if (p[STATE] === state ||\n        p[STATE] !== PENDING) {\n      return;\n    }\n\n    p[STATE] = state;\n    p[VALUE] = value;\n\n    return processNextTick(p);\n  }\n\n  self.PromiseImpl = PromiseImpl;\n  self.CancellationError = CancellationError;\n  self.isCancellationError = isCancellationError;\n\n  self.deferred = () => {\n    return new PromiseImpl();\n  };\n\n  const NULL_PROMISE = new PromiseImpl(null);\n\n  self.resolved = function resolved (value) {\n    if (value === null) {\n      return NULL_PROMISE;\n    } else {\n      const p = new PromiseImpl();\n      p[STATE] = RESOLVED;\n      p[VALUE] = value;\n      // console.log(\"++ [resolved]\", \"uid:\", goog.getUid(p), \"value:\", value);\n\n      return p;\n    }\n  };\n\n  self.rejected = function rejected (reason) {\n    const p = new PromiseImpl();\n    p[STATE] = REJECTED;\n    p[VALUE] = reason;\n\n    // console.log(\"++ [rejected]\", \"uid:\", goog.getUid(p), \"value:\", fmtValue(reason));\n\n    return p;\n  };\n\n  self.all = function all (promises) {\n    return promises.reduce((acc, p) => {\n      return acc.then((results) => {\n        return self.coerce(p).fmap((v) => {\n          results.push(v);\n          return results;\n        });\n      });\n    }, self.resolved([]));\n  };\n\n  self.coerce = function coerce (promise) {\n    if (promise instanceof PromiseImpl) {\n      return promise;\n    } else if (isThenable(promise)) {\n      const deferred = self.deferred();\n      promise.then((v) => {\n        deferred.resolve(v);\n      }, (c) => {\n        deferred.reject(c);\n      });\n      return deferred;\n    } else if (promise instanceof Error) {\n      return self.rejected(promise);\n    } else {\n      return self.resolved(promise);\n    }\n  };\n\n  self.race = function race (promises) {\n    const deferred = self.deferred();\n\n    promises.forEach((p) => {\n      self.coerce(p).handle((v, c) => {\n        if (c) {\n          deferred.reject(c);\n        } else {\n          deferred.resolve(v);\n        }\n      });\n    });\n\n    return deferred;\n  };\n\n  self.nextTick = nextTick;\n\n  self.PENDING = PENDING;\n  self.RESOLVED = RESOLVED;\n  self.REJECTED = REJECTED;\n});\n","~:last-modified",1709564786609,"~:requires",["^3",["~$goog"]],"~:pom-info",["^ ","~:group-id","~$funcool","~:artifact-id","~$promesa","~:version","11.0.678","~:name","promesa","~:description","A promise library and concurency toolkit for Clojure and ClojureScript.","~:url","https://github.com/funcool/promesa","~:id","~$funcool/promesa","~:coordinate",["^K","11.0.678"]],"~:goog-requires",["^3",[]],"~:inspect-info",["^ ","~:js-str-offsets",[],"~:js-esm",false,"~:js-imports",[],"~:js-invalid-requires",[],"^2",["promesa.impl.promise","promesa.impl.promise.PromiseImpl","promesa.impl.promise.CancellationError"],"~:js-language","es_2020","~:goog-module",null,"~:goog-module-legacy-namespace",false,"~:js-requires",[],"^M",[],"~:js-dynamic-imports",[],"~:goog-require-types",[],"~:uses-global-buffer",false,"~:uses-global-process",false],"^I",["~#url","jar:file:/Users/john/.m2/repository/funcool/promesa/11.0.678/promesa-11.0.678.jar!/promesa/impl/promise.js"],"~:provides",["^3",["^4","^5","^6"]],"^X",["^3",[]],"~:from-jar",true,"~:goog-src",false,"~:deps",["^@"]]],"~:shadow.build.classpath/CACHE-TIMESTAMP",1733506754000]